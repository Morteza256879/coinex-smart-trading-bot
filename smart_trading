import time
import json
import requests
import ccxt
import pandas as pd
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from io import BytesIO
from ta.trend import EMAIndicator, MACD
from ta.momentum import RSIIndicator
from ta.volatility import BollingerBands, AverageTrueRange
import threading
import mplfinance as mpf
import os
import logging
from typing import Dict, List, Optional, Tuple
from dotenv import load_dotenv

# Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ù…Ø­ÛŒØ·ÛŒ
load_dotenv()
MAIN_BOT_TOKEN = os.getenv("MAIN_BOT_TOKEN")
if not MAIN_BOT_TOKEN:
    raise ValueError("MAIN_BOT_TOKEN environment variable not set")

# ===============================
# ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡
# ===============================
POSITIONS_FILE = "positions.json"
RISK_PERCENT = 1.0
MIN_TRADE_VALUE = 11.5427  # â‰ˆ 0.0001 BTC (Ø­Ø¯Ø§Ù‚Ù„ Ø³ÙØ§Ø±Ø´ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù‚ÙˆØ§Ù†ÛŒÙ† Ú©ÙˆÛŒÙ†Ú©Ø³)
# Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ… Ø³ÙˆØ¦ÛŒÚ†ÛŒÙ†Ú¯
MIN_HOLD_MINUTES = 10
SWITCH_MARGIN = 0.05
MAX_SWITCHES_PER_HOUR = 4
SCORE_THRESHOLD = 0.6
VOLUME_THRESHOLD = 1000000  # 1M USD
# ÙˆØ²Ù†â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ… Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ
WEIGHT_VOLATILITY = 0.35
WEIGHT_LIQUIDITY = 0.30
WEIGHT_MOMENTUM = 0.20
WEIGHT_PATTERN = 0.15
# ØªØ§ÛŒÙ… ÙØ±ÛŒÙ… Ù‡Ø§
TIMEFRAMES = {
    "1m": 60,
    "5m": 300,
    "15m": 900,
    "30m": 1800,
    "1h": 3600,
    "4h": 14400,
    "1d": 86400
}
# Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ
REQUIRE_ALL_CONFIRMATIONS = True
RSI_BULL, RSI_BEAR = 55.0, 45.0
EMA_FAST, EMA_SLOW = 50, 200
MACD_FAST, MACD_SLOW, MACD_SIGNAL = 12, 26, 9
BB_WINDOW, BB_DEV = 20, 2
ATR_WINDOW = 14
ATR_SL_MULTIPLIER = 1.5
ATR_TP_MULTIPLIERS = [1.0, 2.0, 3.0]
# Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ…
is_running = False
current_symbol = None
current_position = None
switch_count = 0
last_switch_time = datetime.now()
symbol_scores = {}
market_data = {}
previous_signals = {}
last_run = {tf: 0 for tf in TIMEFRAMES}
# Ù…Ø¯ÛŒØ±ÛŒØª Ø³Ø±Ù…Ø§ÛŒÙ‡
waiting_for_wallet_balance = False
waiting_for_trading_percentage = False
# ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù„Ø§Ú¯â€ŒÚ¯ÛŒØ±ÛŒ
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# ===============================
# 1. Ù…Ø¯ÛŒØ±ÛŒØª ÙØ§ÛŒÙ„ Ù¾ÙˆØ²ÛŒØ´Ù†
# ===============================
def load_positions(chat_id):
    filename = f"positions_{chat_id}.json"
    try:
        if not os.path.exists(filename):
            return {"positions": [], "wallet_balance": None, "trading_capital": None, "capital": None}
        with open(filename, "r", encoding="utf-8") as f:
            data = json.load(f)
            for key in ["wallet_balance", "trading_capital", "capital"]:
                if key not in data:
                    data[key] = None
            for pos in data.get("positions", []):
                pos.setdefault("volume", 0.0)
                pos.setdefault("entry", 0.0)
                pos.setdefault("sl", 0.0)
                pos.setdefault("tps", [])
                pos.setdefault("profit_dollar", 0.0)
                pos.setdefault("hit_tps", [])
                pos.setdefault("tp_times", {})
                pos.setdefault("sl_time", None)
                pos.setdefault("close_time", None)
            return data
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ù¾ÙˆØ²ÛŒØ´Ù†â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± {chat_id}: {e}")
        return {"positions": [], "wallet_balance": None, "trading_capital": None, "capital": None}

def save_positions(data, chat_id):
    filename = f"positions_{chat_id}.json"
    try:
        with open(filename, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ù¾ÙˆØ²ÛŒØ´Ù†â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± {chat_id}: {e}")

# ===============================
# 2. Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø§Ø¯Ù‡ Ø¨Ø§Ø²Ø§Ø±
# ===============================
class MarketData:
    def __init__(self):
        self.symbols = []
        self.ohlcv_data = {}
        self.market_metrics = {}
        self.last_update = {}
    
    def fetch_all_symbols(self, exchange, min_volume=VOLUME_THRESHOLD):
        """Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ù… Ù†Ù…Ø§Ø¯Ù‡Ø§ Ø¨Ø§ ÙÛŒÙ„ØªØ± Ø­Ø¬Ù…"""
        try:
            markets = exchange.load_markets()
            valid_symbols = []
            for symbol, market in markets.items():
                if market.get('quote') == 'USDT' and market.get('active', False):
                    volume_str = market.get('info', {}).get('volumeQuote', '0')
                    try:
                        volume_float = float(volume_str.replace(',', '')) if isinstance(volume_str, str) else float(volume_str)
                    except ValueError:
                        volume_float = 0.0
                    if volume_float >= min_volume:
                        valid_symbols.append(symbol)
            self.symbols = valid_symbols[:50]
            logger.info(f"Found {len(self.symbols)} symbols with sufficient volume")
            if len(self.symbols) == 0:
                logger.warning(f"No symbols found above volume threshold of {min_volume:,.0f} USD")
            return self.symbols
        except Exception as e:
            logger.error(f"Error fetching symbols: {e}")
            return []
    
    def fetch_ohlcv_data(self, exchange, symbols, timeframe='1h', limit=100):
        """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ OHLCV Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§Ø¯Ù‡Ø§"""
        ohlcv_data = {}
        for symbol in symbols:
            try:
                ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
                df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                ohlcv_data[symbol] = df
                self.last_update[symbol] = datetime.now()
            except Exception as e:
                logger.error(f"Error fetching OHLCV for {symbol}: {e}")
        self.ohlcv_data = ohlcv_data
        return ohlcv_data
    
    def calculate_market_metrics(self):
        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø¨Ø±Ø§ÛŒ ØªÙ…Ø§Ù… Ù†Ù…Ø§Ø¯Ù‡Ø§"""
        market_metrics = {}
        atr_values = []
        volume_values = []
        for symbol, df in self.ohlcv_data.items():
            try:
                atr = self.calculate_atr(df)
                atr_values.append(atr)
                volume = df['volume'].mean()
                volume_values.append(volume)
                momentum = self.calculate_momentum(df)
                pattern_score = self.calculate_pattern_score(df)
                market_metrics[symbol] = {
                    'atr': atr,
                    'volume': volume,
                    'momentum': momentum,
                    'pattern_score': pattern_score
                }
            except Exception as e:
                logger.error(f"Error calculating metrics for {symbol}: {e}")
        avg_atr = np.mean(atr_values) if atr_values else 1
        avg_volume = np.mean(volume_values) if volume_values else 1
        self.market_metrics = market_metrics
        return market_metrics, avg_atr, avg_volume
    
    def calculate_atr(self, df, window=14):
        try:
            high = df['high']
            low = df['low']
            close = df['close']
            tr = np.maximum(high - low, 
                           np.maximum(abs(high - close.shift()), 
                                     abs(low - close.shift())))
            atr = tr.rolling(window=window).mean().iloc[-1]
            return atr
        except:
            return 0
    
    def calculate_momentum(self, df, periods=[5, 10, 20]):
        try:
            close = df['close']
            momentum_scores = []
            for period in periods:
                returns = (close.iloc[-1] / close.iloc[-period] - 1) * 100
                momentum_scores.append(returns)
            return np.mean(momentum_scores)
        except:
            return 0
    
    def calculate_pattern_score(self, df):
        try:
            score = 0
            recent_high = df['high'].iloc[-5:].max()
            if df['close'].iloc[-1] > recent_high:
                score += 0.3
            rsi = RSIIndicator(df['close'], window=14).rsi().iloc[-1]
            if 50 < rsi < 70:
                score += 0.2
            elif rsi > 70:
                score -= 0.1
            macd_ind = MACD(df['close'], window_fast=12, window_slow=26, window_sign=9)
            macd = macd_ind.macd().iloc[-1]
            signal = macd_ind.macd_signal().iloc[-1]
            if macd > signal:
                score += 0.2
            ema_fast = EMAIndicator(df['close'], window=50).ema_indicator().iloc[-1]
            ema_slow = EMAIndicator(df['close'], window=200).ema_indicator().iloc[-1]
            if ema_fast > ema_slow:
                score += 0.3
            return max(0, min(1, score))
        except Exception as e:
            logger.error(f"Error calculating pattern score: {e}")
            return 0

# ===============================
# 3. Ø³ÛŒØ³ØªÙ… Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ
# ===============================
class ScoringSystem:
    def __init__(self, weight_volatility=0.35, weight_liquidity=0.30, 
                 weight_momentum=0.20, weight_pattern=0.15):
        self.weights = {
            'volatility': weight_volatility,
            'liquidity': weight_liquidity,
            'momentum': weight_momentum,
            'pattern': weight_pattern
        }
    
    def calculate_score(self, symbol_metrics, avg_atr, avg_volume):
        try:
            vol_norm = self.normalize_volatility(symbol_metrics['atr'], avg_atr)
            liq_norm = self.normalize_liquidity(symbol_metrics['volume'], avg_volume)
            mom_norm = self.normalize_momentum(symbol_metrics['momentum'])
            pattern_score = symbol_metrics['pattern_score']
            score = (self.weights['volatility'] * vol_norm +
                    self.weights['liquidity'] * liq_norm +
                    self.weights['momentum'] * mom_norm +
                    self.weights['pattern'] * pattern_score)
            return max(0, min(1, score))
        except Exception as e:
            logger.error(f"Error calculating score for {symbol_metrics}: {e}")
            return 0
    
    def normalize_volatility(self, atr, avg_atr):
        if avg_atr == 0:
            return 0
        ratio = atr / avg_atr
        return min(1.0, ratio / 2.0)
    
    def normalize_liquidity(self, volume, avg_volume):
        if avg_volume == 0:
            return 0
        try:
            log_volume = np.log10(volume)
            log_avg = np.log10(avg_volume)
            log_threshold = np.log10(VOLUME_THRESHOLD)
            if log_volume >= log_threshold:
                return 1.0
            else:
                return max(0, min(1, (log_volume - log_avg) / (log_threshold - log_avg)))
        except:
            return 0
    
    def normalize_momentum(self, momentum):
        return max(0, min(1, (momentum + 20) / 40))

# ===============================
# 4. Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÙˆØ²ÛŒØ´Ù† Ùˆ Ø³ÙˆØ¦ÛŒÚ†ÛŒÙ†Ú¯
# ===============================
class PositionManager:
    def __init__(self):
        self.current_symbol = None
        self.entry_time = None
        self.entry_price = None
        self.position_size = 0
        self.stop_loss = 0
        self.take_profit = 0
        self.initial_atr = 0
        self.initial_volume = 0
    
    def should_switch(self, new_score, current_score, market_data):
        if self.current_symbol is None:
            return True
        if self.entry_time and (datetime.now() - self.entry_time).total_seconds() < MIN_HOLD_MINUTES * 60:
            return False
        if new_score < current_score * (1 + SWITCH_MARGIN):
            return False
        if self.check_current_symbol_conditions(market_data):
            return True
        return False
    
    def check_current_symbol_conditions(self, market_data):
        if self.current_symbol not in market_data.ohlcv_data:
            return True
        df = market_data.ohlcv_data[self.current_symbol]
        current_atr = market_data.calculate_atr(df)
        if current_atr < self.initial_atr * 0.7:
            return True
        current_volume = df['volume'].mean()
        if current_volume < self.initial_volume * 0.5:
            return True
        if self.check_technical_exit(df):
            return True
        return False
    
    def check_technical_exit(self, df):
        try:
            rsi = RSIIndicator(df['close'], window=14).rsi().iloc[-1]
            if rsi < 30 or rsi > 80:
                return True
            macd_ind = MACD(df['close'], window_fast=12, window_slow=26, window_sign=9)
            macd = macd_ind.macd().iloc[-1]
            signal = macd_ind.macd_signal().iloc[-1]
            if macd < signal:
                return True
            return False
        except Exception as e:
            logger.error(f"Error checking technical exit: {e}")
            return False

# ===============================
# 5. Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ùˆ Ú†Ø§Ø±Øª Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù…
# ===============================
def send_message(chat_id, text, reply_markup=None, bot_token=None):
    try:
        # Ø§Ú¯Ø± ØªÙˆÚ©Ù† Ø¯Ø§Ø¯Ù‡ Ù†Ø´Ø¯Ù‡ØŒ Ø§Ø² Ú©Ø§Ø±Ø¨Ø± ÙØ¹Ù„ÛŒ Ø¨Ú¯ÛŒØ±
        if bot_token is None:
            users_data = load_users()
            user = users_data.get(str(chat_id))
            if not user:
                # Ø§Ú¯Ø± Ú©Ø§Ø±Ø¨Ø± ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø§Ø² ØªÙˆÚ©Ù† Ù…Ø±Ú©Ø²ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
                bot_token = MAIN_BOT_TOKEN
            else:
                bot_token = user["telegram_token"]
        
        if len(text) > 4000:
            text = text[:4000] + "... (Ù¾ÛŒØ§Ù… Ú©ÙˆØªØ§Ù‡ Ø´Ø¯)"
        data = {"chat_id": chat_id, "text": text, "parse_mode": "HTML"}
        if reply_markup:
            data["reply_markup"] = json.dumps(reply_markup)
        response = requests.post(f"https://api.telegram.org/bot{bot_token}/sendMessage", data=data, timeout=15)
        if not response.ok:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… ØªÙ„Ú¯Ø±Ø§Ù… Ø¨Ù‡ {chat_id}: {response.text}")
            return False
        return True
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ {chat_id}: {e}")
        return False

def send_chart(chat_id, image_bytes, caption="", bot_token=None):
    try:
        # Ø§Ú¯Ø± ØªÙˆÚ©Ù† Ø¯Ø§Ø¯Ù‡ Ù†Ø´Ø¯Ù‡ØŒ Ø§Ø² Ú©Ø§Ø±Ø¨Ø± ÙØ¹Ù„ÛŒ Ø¨Ú¯ÛŒØ±
        if bot_token is None:
            users_data = load_users()
            user = users_data.get(str(chat_id))
            if not user:
                # Ø§Ú¯Ø± Ú©Ø§Ø±Ø¨Ø± ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø§Ø² ØªÙˆÚ©Ù† Ù…Ø±Ú©Ø²ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
                bot_token = MAIN_BOT_TOKEN
            else:
                bot_token = user["telegram_token"]
        
        files = {"photo": image_bytes}
        data = {"chat_id": chat_id, "caption": caption}
        response = requests.post(f"https://api.telegram.org/bot{bot_token}/sendPhoto", data=data, files=files, timeout=30)
        if not response.ok:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú†Ø§Ø±Øª ØªÙ„Ú¯Ø±Ø§Ù… Ø¨Ù‡ {chat_id}: {response.text}")
            return False
        return True
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ú†Ø§Ø±Øª Ø¨Ù‡ {chat_id}: {e}")
        return False

# ===============================
# 6. Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†
# ===============================
USERS_FILE = "users.json"

def load_users():
    if not os.path.exists(USERS_FILE):
        return {}
    with open(USERS_FILE, "r", encoding="utf-8") as f:
        return json.load(f)

def save_users(users):
    with open(USERS_FILE, "w", encoding="utf-8") as f:
        json.dump(users, f, ensure_ascii=False, indent=2)

def get_user_exchange(chat_id):
    users_data = load_users()
    user = users_data.get(str(chat_id))
    if not user:
        return None
    exchange_name = user["exchange"]
    api_key = user["api_key"]
    api_secret = user["api_secret"]
    exchange_class = ccxt.coinex
    exchange = exchange_class({
        "apiKey": api_key,
        "secret": api_secret,
        "enableRateLimit": True,
        "timeout": 30000,
        "options": {"defaultType": "future" if user["trade_mode"] == "futures" else "spot"}
    })
    return exchange

def fetch_ohlcv(symbol, timeframe, limit=400, chat_id=None):
    if not chat_id:
        return None
    exchange = get_user_exchange(chat_id)
    if not exchange:
        return None
    try:
        ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
        df = pd.DataFrame(ohlcv, columns=["time", "open", "high", "low", "close", "volume"])
        df["time"] = pd.to_datetime(df["time"], unit="ms")
        for col in ["open", "high", "low", "close", "volume"]:
            df[col] = pd.to_numeric(df[col], errors="coerce")
        df.dropna(inplace=True)
        return df
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ {symbol}-{timeframe} Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± {chat_id}: {e}")
        return None

def execute_order(symbol, side, amount, params=None, chat_id=None):
    if not chat_id:
        return None
    exchange = get_user_exchange(chat_id)
    if not exchange:
        return None
    params = params or {}
    users_data = load_users()
    user = users_data.get(str(chat_id))
    if user["is_demo"]:
        msg = f"ğŸ”¹ Demo: Order {side.upper()} for {symbol} with volume {amount:.6f} simulated."
        send_message(chat_id, msg, bot_token=user["telegram_token"])
        return {"id": f"demo-{int(time.time())}"}

    if exchange.name == "coinex" and side == "buy":
        params['createMarketBuyOrderRequiresPrice'] = False
    try:
        order = exchange.create_market_order(symbol, side, amount, params=params)
        return order
    except Exception as e:
        send_message(chat_id, f"âŒ Ø®Ø·Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø³ÙØ§Ø±Ø´: {str(e)}", bot_token=user["telegram_token"])
        raise Exception(f"Execution failed: {e}")

def place_futures_exit_orders(symbol, direction, volume, sl, tps, chat_id):
    users_data = load_users()
    user = users_data.get(str(chat_id))
    if user["is_demo"]:
        return {"sl_id": f"demo-sl-{int(time.time())}", "tp_ids": [f"demo-tp-{i}" for i in range(len(tps))]}
    
    exchange = get_user_exchange(chat_id)
    if not exchange:
        return None
    
    try:
        sl_side = "sell" if direction == "buy" else "buy"
        sl_params = {
            "stopPrice": sl, 
            "triggerPrice": sl, 
            "reduceOnly": True,
            "margin_mode": "isolated"
        }
        sl_order = exchange.create_order(symbol, "stop_market", sl_side, volume, params=sl_params)
        
        tp_side = "sell" if direction == "buy" else "buy"
        tp_volume = volume / len(tps)
        tp_ids = []
        for tp in tps:
            tp_params = {
                "reduceOnly": True,
                "margin_mode": "isolated"
            }
            tp_order = exchange.create_limit_order(symbol, tp_side, tp_volume, tp, params=tp_params)
            tp_ids.append(tp_order["id"])
        return {"sl_id": sl_order["id"], "tp_ids": tp_ids}
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± ØªÙ†Ø¸ÛŒÙ… Ø³ÙØ§Ø±Ø´Ø§Øª Ø®Ø±ÙˆØ¬ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± {chat_id}: {e}")
        return {"sl_id": None, "tp_ids": []}

def calculate_volume(symbol, entry, sl, direction, chat_id):
    distance = abs(entry - sl)
    if distance <= 0:
        return 0.0
    users_data = load_users()
    user = users_data.get(str(chat_id))
    risk_amount_usd = user["trading_capital"] * RISK_PERCENT / 100.0
    if risk_amount_usd <= 0:
        return 0.0
    volume_base = risk_amount_usd / distance
    notional_value = volume_base * entry
    if notional_value < MIN_TRADE_VALUE:
        volume_base = MIN_TRADE_VALUE / entry
    return volume_base

# ===============================
# 7. Ø±Ø³Ù… Ú†Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ (Ù†Ø³Ø®Ù‡ Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯)
# ===============================
def plot_dashboard_chart(ind_df, symbol, timeframe, signal, position_data=None):
    """
    Plots a comprehensive dashboard chart including candles, indicators, and trade plan.
    Args:
        ind_df (pd.DataFrame): DataFrame with OHLCV and indicator data.
        symbol (str): Trading pair symbol.
        timeframe (str): Timeframe of the data.
        signal (str): Trading signal (e.g., 'buy', 'sell').
        position_data (dict, optional): Dictionary containing position details
                                        (entry, sl, tps, direction, close_price).
                                        Defaults to None.
    """
    df = ind_df.tail(100).copy()
    df_mpf = df.set_index("time")[["open", "high", "low", "close", "volume"]]
    df_mpf.index = pd.to_datetime(df_mpf.index)
    add_plots = [
        mpf.make_addplot(df["EMA_FAST"], color="blue", width=0.8),
        mpf.make_addplot(df["EMA_SLOW"], color="red", width=0.8),
        mpf.make_addplot(df["BB_HIGH"], color="orange", linestyle="--", alpha=0.7),
        mpf.make_addplot(df["BB_LOW"], color="orange", linestyle="--", alpha=0.7),
    ]
    if position_data:
        add_plots.append(mpf.make_addplot([position_data["entry"]] * len(df_mpf), color="blue", linestyle="--", width=0.8, panel=0))
        add_plots.append(mpf.make_addplot([position_data["sl"]] * len(df_mpf), color="red", linestyle="--", width=0.8, panel=0))
        for tp in position_data["tps"]:
            add_plots.append(mpf.make_addplot([tp] * len(df_mpf), color="green", linestyle="--", width=0.8, panel=0))
        if position_data.get("close_price"):
            add_plots.append(mpf.make_addplot([position_data["close_price"]] * len(df_mpf), color="purple", linestyle="--", width=0.8, panel=0))
    add_plots_volume_rsi = [
        mpf.make_addplot(df["volume"], panel=1, color="gray", type="bar", ylabel="Volume"),
        mpf.make_addplot(df["RSI"], panel=1, color="blue", ylabel="RSI"),
    ]
    add_plots_volume_rsi.extend([
        mpf.make_addplot([70] * len(df_mpf), panel=1, color="red", linestyle="--", alpha=0.5),
        mpf.make_addplot([30] * len(df_mpf), panel=1, color="green", linestyle="--", alpha=0.5),
    ])
    add_plots_macd = [
        mpf.make_addplot(df["MACD"], panel=2, color="blue", ylabel="MACD"),
        mpf.make_addplot(df["MACD_SIGNAL"], panel=2, color="orange"),
    ]
    add_plots_macd.append(mpf.make_addplot([0] * len(df_mpf), panel=2, color="black", linestyle="--", alpha=0.5))
    all_add_plots = add_plots + add_plots_volume_rsi + add_plots_macd
    mc = mpf.make_marketcolors(up="green", down="red", wick="black", edge="black")
    s = mpf.make_mpf_style(marketcolors=mc)
    fig, _ = mpf.plot(
        df_mpf,
        type="candle",
        volume=False,
        addplot=all_add_plots,
        style=s,
        title=f"{symbol} {timeframe} | {signal.upper()} | CoinEx",
        panel_ratios=(6, 3, 2),
        figratio=(14, 9),
        returnfig=True
    )
    buf = BytesIO()
    fig.savefig(buf, format="png", bbox_inches="tight", dpi=100)
    buf.seek(0)
    plt.close(fig)
    return buf

# ===============================
# 8. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
# ===============================
def compute_indicators(df):
    try:
        out = df.copy()
        out["EMA_FAST"] = EMAIndicator(close=out["close"], window=EMA_FAST).ema_indicator()
        out["EMA_SLOW"] = EMAIndicator(close=out["close"], window=EMA_SLOW).ema_indicator()
        out["RSI"] = RSIIndicator(close=out["close"], window=14).rsi()
        macd_ind = MACD(close=out["close"], window_fast=MACD_FAST, window_slow=MACD_SLOW, window_sign=MACD_SIGNAL)
        out["MACD"] = macd_ind.macd()
        out["MACD_SIGNAL"] = macd_ind.macd_signal()
        bb = BollingerBands(close=out["close"], window=BB_WINDOW, window_dev=BB_DEV)
        out["BB_HIGH"] = bb.bollinger_hband()
        out["BB_LOW"] = bb.bollinger_lband()
        out["ATR"] = AverageTrueRange(high=out["high"], low=out["low"], close=out["close"], window=ATR_WINDOW).average_true_range()
        out.dropna(inplace=True)
        return out
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±: {e}")
        return None

# ===============================
# 9. ØªØµÙ…ÛŒÙ… Ø³ÛŒÚ¯Ù†Ø§Ù„
# ===============================
def decide_signal(row_prev, row):
    ema_bull = row["EMA_FAST"] > row["EMA_SLOW"]
    ema_bear = row["EMA_FAST"] < row["EMA_SLOW"]
    rsi_bull = row["RSI"] > RSI_BULL
    rsi_bear = row["RSI"] < RSI_BEAR
    macd_bull = row["MACD"] > row["MACD_SIGNAL"]
    macd_bear = row["MACD"] < row["MACD_SIGNAL"]
    bull_confirms = [ema_bull, rsi_bull, macd_bull]
    bear_confirms = [ema_bear, rsi_bear, macd_bear]
    bull_ok = all(bull_confirms) if REQUIRE_ALL_CONFIRMATIONS else sum(bull_confirms) >= 2
    bear_ok = all(bear_confirms) if REQUIRE_ALL_CONFIRMATIONS else sum(bear_confirms) >= 2
    if bull_ok and not bear_ok:
        return "buy", False
    if bear_ok and not bull_ok:
        return "sell", False
    return "neutral", False

# ===============================
# 10. Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø±Ø¨Ø§Øª Ù‡ÙˆØ´Ù…Ù†Ø¯
# ===============================
class SmartTradingBot:
    def __init__(self, chat_id):
        self.chat_id = chat_id
        self.exchange = None
        self.market_data = MarketData()
        self.scoring_system = ScoringSystem()
        self.position_manager = PositionManager()
        self.symbol_scores = {}
        self.users_data = load_users()
        self.user = self.users_data.get(str(chat_id))
    
    def initialize(self):
        try:
            if not self.user:
                logger.error(f"User {self.chat_id} not found")
                return False
            
            self.exchange = get_user_exchange(self.chat_id)
            if not self.exchange:
                logger.error(f"Exchange not initialized for user {self.chat_id}")
                return False
            
            symbols = self.market_data.fetch_all_symbols(self.exchange)
            if not symbols:
                logger.error("No valid symbols found")
                return False
            
            self.market_data.fetch_ohlcv_data(self.exchange, symbols)
            market_metrics, avg_atr, avg_volume = self.market_data.calculate_market_metrics()
            for symbol, metrics in market_metrics.items():
                score = self.scoring_system.calculate_score(metrics, avg_atr, avg_volume)
                self.symbol_scores[symbol] = score
            
            logger.info(f"Bot initialized successfully for user {self.chat_id}")
            return True
        except Exception as e:
            logger.error(f"Initialization error for user {self.chat_id}: {e}")
            return False
    
    def find_best_symbol(self):
        if not self.symbol_scores:
            return None, 0
        sorted_symbols = sorted(self.symbol_scores.items(), key=lambda x: x[1], reverse=True)
        for symbol, score in sorted_symbols:
            if score >= SCORE_THRESHOLD:
                return symbol, score
        return None, 0
    
    def execute_trade(self, symbol):
        try:
            df = fetch_ohlcv(symbol, "1h", 200, self.chat_id)
            if df is None:
                return False
            ind_df = compute_indicators(df)
            if ind_df is None:
                return False
            row = ind_df.iloc[-1]
            signal, _ = decide_signal(ind_df.iloc[-2], row)
            if signal == "neutral":
                return False
            atr = row["ATR"]
            entry_price = row["close"]
            if signal == "buy":
                sl_price = entry_price - atr * ATR_SL_MULTIPLIER
                tp_prices = [entry_price + atr * mult for mult in ATR_TP_MULTIPLIERS]
            else:
                sl_price = entry_price + atr * ATR_SL_MULTIPLIER  
                tp_prices = [entry_price - atr * mult for mult in ATR_TP_MULTIPLIERS]
            volume = calculate_volume(symbol, entry_price, sl_price, signal, self.chat_id)
            if volume * entry_price < MIN_TRADE_VALUE:
                logger.warning(f"Trade size too small for {symbol}")
                return False
            self.position_manager.current_symbol = symbol
            self.position_manager.entry_time = datetime.now()
            self.position_manager.entry_price = entry_price
            self.position_manager.position_size = volume
            self.position_manager.initial_atr = atr
            self.position_manager.initial_volume = df['volume'].mean()
            self.position_manager.stop_loss = sl_price
            self.position_manager.take_profit = tp_prices
            signal_id = f"{symbol.replace('/', '')}-1h-{datetime.now().strftime('%Y%m%d-%H%M')}"
            msg = f"""
ğŸš€ <b>Smart Switch Signal {signal.upper()}</b>
ğŸ“Œ <b>{symbol}</b> | â±ï¸ <b>1h</b> | ğŸ¦ CoinEx
ğŸ’° Entry: <code>{entry_price:.6f}</code>
ğŸ›‘ SL: <code>{sl_price:.6f}</code>  
ğŸ¯ TP: {" | ".join(f"<code>{tp:.6f}</code>" for tp in tp_prices)}
ğŸ“Š ATR: <code>{atr:.6f}</code>
ğŸ†” Code: <code>{signal_id}</code>
ğŸ“¦ Volume: <code>{volume:.6f}</code> ({volume * entry_price:.2f} USD)
â­ Score: <b>{self.symbol_scores.get(symbol, 0):.3f}</b>
ğŸ¯ Risk: {RISK_PERCENT}%
"""
            send_message(self.chat_id, msg, bot_token=self.user["telegram_token"])
            try:
                position_data = {
                    "entry": entry_price,
                    "sl": sl_price,
                    "tps": tp_prices,
                    "direction": signal
                }
                chart_buf = plot_dashboard_chart(ind_df, symbol, "1h", signal, position_data=position_data)
                send_chart(self.chat_id, chart_buf, f"ğŸ¯ {symbol}-1h Smart Switch Dashboard | Score: {self.symbol_scores.get(symbol, 0):.3f}", bot_token=self.user["telegram_token"])
            except Exception as e:
                logger.error(f"Chart error in execute_trade for user {self.chat_id}: {e}")
            try:
                order = execute_order(symbol, signal, volume, chat_id=self.chat_id)
                send_message(self.chat_id, f"âœ… Smart switch executed. Order ID: <code>{order['id']}</code>", bot_token=self.user["telegram_token"])
                positions = load_positions(self.chat_id)
                new_pos = {
                    "id": signal_id,
                    "symbol": symbol,
                    "timeframe": "1h",
                    "direction": signal,
                    "entry": entry_price,
                    "sl": sl_price,
                    "tps": tp_prices,
                    "volume": volume,
                    "status": "open",
                    "open_time": datetime.now().strftime("%Y-%m-%dT%H:%M:%S"),
                    "order_id": order["id"],
                    "demo": self.user["is_demo"],
                    "exchange": self.user["exchange"],
                    "hit_tps": [],
                    "tp_times": {},
                    "sl_time": None,
                    "close_time": None,
                    "profit_dollar": 0.0,
                    "score": self.symbol_scores.get(symbol, 0)
                }
                positions["positions"].append(new_pos)
                save_positions(positions, self.chat_id)
                logger.info(f"Switched to {symbol} with score {self.symbol_scores.get(symbol, 0):.3f} for user {self.chat_id}")
                return True
            except Exception as e:
                send_message(self.chat_id, f"âŒ Order execution error: {e}", bot_token=self.user["telegram_token"])
                return False
        except Exception as e:
            logger.error(f"Trade execution error for user {self.chat_id}: {e}")
            return False
    
    def run_cycle(self):
        try:
            self.market_data.fetch_ohlcv_data(self.exchange, self.market_data.symbols)
            market_metrics, avg_atr, avg_volume = self.market_data.calculate_market_metrics()
            for symbol, metrics in market_metrics.items():
                score = self.scoring_system.calculate_score(metrics, avg_atr, avg_volume)
                self.symbol_scores[symbol] = score
            best_symbol, best_score = self.find_best_symbol()
            if not best_symbol:
                logger.info("No suitable symbol found above threshold")
                return
            current_score = self.symbol_scores.get(self.position_manager.current_symbol, 0)
            if self.position_manager.should_switch(best_score, current_score, self.market_data):
                if self.position_manager.current_symbol:
                    self.close_position()
                if self.execute_trade(best_symbol):
                    logger.info(f"Successfully switched to {best_symbol} for user {self.chat_id}")
            self.check_exit_conditions()
        except Exception as e:
            logger.error(f"Run cycle error for user {self.chat_id}: {e}")
    
    def close_position(self):
        if self.position_manager.current_symbol:
            symbol = self.position_manager.current_symbol
            logger.info(f"Closing position in {symbol} for user {self.chat_id}")
            send_message(self.chat_id, f"ğŸ”„ Switching from {symbol}", bot_token=self.user["telegram_token"])
            self.position_manager.current_symbol = None
            self.position_manager.entry_time = None
    
    def check_exit_conditions(self):
        if not self.position_manager.current_symbol:
            return
        symbol = self.position_manager.current_symbol
        df = fetch_ohlcv(symbol, "1h", 200, self.chat_id)
        if df is None or df.empty:
            return
        current_price = df['close'].iloc[-1]
        if current_price <= self.position_manager.stop_loss:
            logger.info(f"Stop loss hit for {symbol} for user {self.chat_id}")
            send_message(self.chat_id, f"ğŸ›‘ Stop loss triggered for {symbol}", bot_token=self.user["telegram_token"])
            self.close_position()
            return
        for i, tp_level in enumerate(self.position_manager.take_profit):
            if current_price >= tp_level:
                logger.info(f"Take profit {i+1} hit for {symbol} for user {self.chat_id}")
                send_message(self.chat_id, f"ğŸ¯ Take profit {i+1} hit for {symbol}", bot_token=self.user["telegram_token"])
                break
        if self.position_manager.check_technical_exit(df):
            logger.info(f"Technical exit signal for {symbol} for user {self.chat_id}")
            send_message(self.chat_id, f"ğŸ“‰ Technical exit signal for {symbol}", bot_token=self.user["telegram_token"])
            self.close_position()
            return

# ===============================
# 11. Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…
# ===============================
def manage_positions_tick(chat_id):
    if not all_settings_completed(chat_id) or not is_running_for_user(chat_id):
        return
    positions = load_positions(chat_id)
    changed = False
    for pos in positions.get("positions", []):
        if pos.get("status") != "open":
            continue
        symbol = pos["symbol"]
        timeframe = pos["timeframe"]
        direction = pos["direction"]
        entry = float(pos["entry"])
        sl = float(pos["sl"])
        tps = [float(x) for x in pos.get("tps", [])]
        volume = float(pos.get("volume", 0.0))
        signal_id = pos["id"]
        df = fetch_ohlcv(symbol, timeframe, 200, chat_id)
        if df is None or df.empty:
            continue
        price = float(df["close"].iloc[-1])
        current_time = df["time"].iloc[-1]
        closed = False
        close_price = None
        pos.setdefault("profit_dollar", 0.0)
        pos.setdefault("hit_tps", [])
        pos.setdefault("tp_times", {})
        tp_vol = volume / len(tps) if len(tps) > 0 else 0
        sorted_tps = sorted(tps) if direction == "buy" else sorted(tps, reverse=True)
        for tp in sorted_tps:
            if tp in pos["hit_tps"]:
                continue
            hit_condition = (direction == "buy" and price >= tp) or (direction == "sell" and price <= tp)
            if hit_condition:
                tp_index = tps.index(tp) + 1
                pos["tp_times"][f"TP{tp_index}"] = current_time.isoformat()
                pos["hit_tps"].append(tp)
                tp_pnl = (tp - entry) * tp_vol if direction == "buy" else (entry - tp) * tp_vol
                pos["profit_dollar"] += tp_pnl
                send_message(chat_id, f"âœ… TP{tp_index} hit for {signal_id} | Profit: {tp_pnl:.2f} $ at {current_time}", bot_token=load_users().get(str(chat_id), {}).get("telegram_token"))
                changed = True
        if len(pos["hit_tps"]) == len(tps):
            closed = True
            close_price = tps[-1] if direction == "buy" else tps[0]
            pos["close_time"] = current_time.isoformat()
            send_message(chat_id, f"âœ… Trade {signal_id} fully closed with profit", bot_token=load_users().get(str(chat_id), {}).get("telegram_token"))
        if not closed:
            sl_condition = (direction == "buy" and price <= sl) or (direction == "sell" and price >= sl)
            if sl_condition:
                pos["sl_time"] = current_time.isoformat()
                remaining_vol = volume - (len(pos["hit_tps"]) * tp_vol)
                sl_pnl = (sl - entry) * remaining_vol if direction == "buy" else (entry - sl) * remaining_vol
                pos["profit_dollar"] += sl_pnl
                send_message(chat_id, f"âŒ SL hit for {signal_id} | Loss: {sl_pnl:.2f} $", bot_token=load_users().get(str(chat_id), {}).get("telegram_token"))
                closed = True
                close_price = sl
                pos["close_time"] = current_time.isoformat()
                changed = True
        if closed:
            pos["status"] = "closed"
            pos["close_price"] = close_price
            pos["profit_percent"] = pos["profit_dollar"] / load_users().get(str(chat_id), {}).get("trading_capital", 0) * 100 if load_users().get(str(chat_id), {}).get("trading_capital", 0) > 0 else 0
    if changed:
        save_positions(positions, chat_id)

def show_main_menu(chat_id):
    users_data = load_users()
    user = users_data.get(str(chat_id))
    if not user:
        return
    
    exchange_text = user["exchange"].upper()
    mode_text = "ğŸ® Demo" if user["is_demo"] else "ğŸ’¸ Real"
    trade_text = user["trade_mode"].upper()
    keyboard = {
        "inline_keyboard": [
            [{"text": "âš™ï¸ Settings", "callback_data": f"settings_{chat_id}"}],
            [{"text": "ğŸ“Š Performance Report", "callback_data": f"report_{chat_id}"}],
            [{"text": "ğŸš¦ Bot Status", "callback_data": f"status_{chat_id}"}],
            [{"text": "ğŸ›‘ Stop", "callback_data": f"stop_bot_{chat_id}"}, {"text": "ğŸŸ¢ Start", "callback_data": f"start_bot_{chat_id}"}]
        ]
    }
    msg = f"""
ğŸ¤– <b>Smart Trading Bot</b>
ğŸ¦ Total Capital: <b>{user["total_wallet_balance"]:.2f} $</b>
ğŸ’¼ Trading Capital: <b>{user["trading_capital"]:.2f} $</b>
ğŸ“ Mode: <b>{mode_text}</b>
ğŸ“Š Market: <b>{trade_text}</b>
ğŸ¦ Exchange: <b>{exchange_text}</b>
"""
    send_message(chat_id, msg, keyboard, bot_token=user["telegram_token"])

def show_settings_menu(chat_id):
    users_data = load_users()
    user = users_data.get(str(chat_id))
    if not user:
        return
    
    exchange_text = user["exchange"].upper()
    mode_text = "ğŸ® Demo" if user["is_demo"] else "ğŸ’¸ Real"
    trade_text = user["trade_mode"].upper()
    text = f"""
âš™ï¸ <b>Settings Menu</b>
ğŸ¦ Exchange: <b>{exchange_text}</b>
ğŸ“ Mode: <b>{mode_text}</b>
ğŸ“Š Market: <b>{trade_text}</b>
"""
    keyboard = {
        "inline_keyboard": [
            [{"text": f"ğŸ”„ Exchange: {exchange_text}", "callback_data": f"select_exchange_{chat_id}"}],
            [{"text": f"ğŸ® Mode: {mode_text}", "callback_data": f"select_mode_{chat_id}"}],
            [{"text": f"ğŸŒ Market: {trade_text}", "callback_data": f"select_trade_mode_{chat_id}"}],
            [{"text": "ğŸ”™ Back", "callback_data": f"main_menu_{chat_id}"}]
        ]
    }
    send_message(chat_id, text, keyboard, bot_token=user["telegram_token"])

def show_exchange_selection(chat_id):
    users_data = load_users()
    user = users_data.get(str(chat_id))
    if not user:
        return
    
    keyboard = {
        "inline_keyboard": [
            [{"text": "Coinex", "callback_data": f"select_coinex_{chat_id}"}]
        ]
    }
    send_message(chat_id, "Please select exchange:", keyboard, bot_token=user["telegram_token"])

def show_mode_selection(chat_id):
    users_data = load_users()
    user = users_data.get(str(chat_id))
    if not user:
        return
    
    keyboard = {
        "inline_keyboard": [
            [{"text": "ğŸ® Demo", "callback_data": f"mode_demo_{chat_id}"}],
            [{"text": "ğŸ’¸ Real", "callback_data": f"mode_real_{chat_id}"}]
        ]
    }
    send_message(chat_id, "Select trade mode:", keyboard, bot_token=user["telegram_token"])

def show_trade_mode_selection(chat_id):
    users_data = load_users()
    user = users_data.get(str(chat_id))
    if not user:
        return
    
    keyboard = {
        "inline_keyboard": [
            [{"text": "SPOT", "callback_data": f"trade_spot_{chat_id}"}],
            [{"text": "FUTURES", "callback_data": f"trade_futures_{chat_id}"}]
        ]
    }
    send_message(chat_id, "Select market type:", keyboard, bot_token=user["telegram_token"])

def all_settings_completed(chat_id):
    users_data = load_users()
    user = users_data.get(str(chat_id))
    if not user:
        return False
    return (user["exchange"] is not None and
            user["trade_mode"] is not None and
            user["is_demo"] is not None and
            user["total_wallet_balance"] is not None and
            user["trading_capital"] is not None)

def is_running_for_user(chat_id):
    # Ø§ÛŒÙ†Ø¬Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ù…Ù†Ø·Ù‚ÛŒ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø§Ø¬Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ú©Ø§Ø±Ø¨Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯
    return True

def send_performance_report(chat_id):
    try:
        users_data = load_users()
        user = users_data.get(str(chat_id))
        if not user:
            send_message(chat_id, "âš ï¸ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯", bot_token=MAIN_BOT_TOKEN)
            return
        
        positions = load_positions(chat_id)
        wallet_balance = user["total_wallet_balance"]
        trading_capital_stored = user["trading_capital"]
        capital = trading_capital_stored
        closed_positions = [p for p in positions.get("positions", []) if p.get("status") == "closed"]
        open_positions = [p for p in positions.get("positions", []) if p.get("status") == "open"]
        wins = sum(1 for p in closed_positions if p.get("profit_dollar", 0) > 0)
        losses = sum(1 for p in closed_positions if p.get("profit_dollar", 0) < 0)
        neutral = len([p for p in positions.get("positions", []) if p.get("profit_dollar", 0) == 0])
        total = wins + losses + neutral
        winrate = (wins / total * 100) if total > 0 else 0.0
        total_pnl = sum(p.get("profit_dollar", 0.0) for p in closed_positions)
        avg_pnl = total_pnl / len(closed_positions) if closed_positions else 0.0
        report_summary = f"""
ğŸ“Š <b>Smart Trading Performance Report</b>
ğŸ“¢ Total Trades: <b>{total}</b>
âœ… Profitable Trades: <b>{wins}</b>
âŒ Loss-making Trades: <b>{losses}</b>
ğŸ”„ Neutral Trades: <b>{neutral}</b>
ğŸ¯ Win Rate: <b>{winrate:.1f}%</b>
ğŸ’° Total Capital: <b>{wallet_balance:.2f} $</b>
ğŸ’¼ Trading Capital: <b>{trading_capital_stored:.2f} $</b>
ğŸ“ˆ Total P/L: <b>{total_pnl:.2f} $</b>
ğŸ“Š Avg P/L per Trade: <b>{avg_pnl:.2f} $</b>
ğŸ¦ Current Capital: <b>{capital:.2f} $</b>
ğŸ“ Open Positions: <b>{len(open_positions)}</b>
ğŸ“ Closed Positions: <b>{len(closed_positions)}</b>
"""
        send_message(chat_id, report_summary, bot_token=user["telegram_token"])
        
        # Ø³Ø§Ø®Øª Ú†Ø§Ø±Øª (Ú©Ø¯ Ø³Ø§Ø®Øª Ú†Ø§Ø±Øª Ø±Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø² Ù†Ø³Ø®Ù‡ Ù‚Ø¨Ù„ÛŒ Ú©Ù¾ÛŒ Ú©Ù†ÛŒØ¯)
        # ...
        
        send_message(chat_id, "âœ… Ú¯Ø²Ø§Ø±Ø´ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ú©Ø§Ù…Ù„ Ø¨Ø§ Ú†Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ ØªØ±Ú©ÛŒØ¨ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.", bot_token=user["telegram_token"])
    except Exception as e:
        error_msg = f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ø¹Ù…Ù„Ú©Ø±Ø¯: {str(e)}"
        logger.error(error_msg)
        send_message(chat_id, error_msg, bot_token=MAIN_BOT_TOKEN)

def show_status(chat_id):
    users_data = load_users()
    user = users_data.get(str(chat_id))
    if not user:
        send_message(chat_id, "âš ï¸ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯", bot_token=MAIN_BOT_TOKEN)
        return
    
    positions = load_positions(chat_id)
    capital = positions.get("capital") or user["trading_capital"]
    wins = sum(1 for p in positions.get("positions", []) if p.get("status") == "closed" and p.get("profit_dollar", 0) > 0)
    losses = sum(1 for p in positions.get("positions", []) if p.get("status") == "closed" and p.get("profit_dollar", 0) < 0)
    total = wins + losses
    winrate = (wins / total * 100) if total > 0 else 0
    realized_pnl = sum(p.get("profit_dollar", 0.0) for p in positions.get("positions", []))
    current_capital_value = user["trading_capital"] + realized_pnl
    status = "ğŸŸ¢ Active" if is_running_for_user(chat_id) else "ğŸ”´ Stopped"
    msg = f"""
ğŸš¦ <b>Smart Bot Status</b>
{status}
ğŸ¦ Total Capital: <b>{user["total_wallet_balance"]:.2f} $</b>
ğŸ’¼ Trading Capital: <b>{user["trading_capital"]:.2f} $</b>
ğŸ“ˆ Trades: {total} (âœ…{wins} / âŒ{losses})
ğŸ¯ Win Rate: <b>{winrate:.1f}%</b>
ğŸ“ˆ Total PNL: <b>{realized_pnl:.2f} $</b>
ğŸ’° Current Capital: <b>{current_capital_value:.2f} $</b>
ğŸ”„ Current Symbol: <b>{current_symbol or 'None'}</b>
"""
    keyboard = {"inline_keyboard": [[{"text": "ğŸ”™ Main Menu", "callback_data": f"main_menu_{chat_id}"}]]}
    send_message(chat_id, msg, keyboard, bot_token=user["telegram_token"])

def handle_telegram_messages():
    users = load_users()
    user_state = {}  # Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª ÙˆØ±ÙˆØ¯ Ú©Ø§Ø±Ø¨Ø± (Ù…ÙˆÙ‚Øª Ø¯Ø± Ø­Ø§ÙØ¸Ù‡)
    last_update_id = 0
    
    while True:
        try:
            resp = requests.get(f"https://api.telegram.org/bot{MAIN_BOT_TOKEN}/getUpdates?offset={last_update_id}&timeout=30", timeout=40)
            if not resp.ok:
                logger.error(f"Telegram update error: {resp.text}")
                time.sleep(5)
                continue
                
            data = resp.json()
            if "result" not in data or not data["result"]:
                time.sleep(1)
                continue
                
            for update in data["result"]:
                last_update_id = update["update_id"] + 1
                if "message" in update and "text" in update["message"]:
                    text = update["message"]["text"].strip()
                    chat_id = str(update["message"]["chat"]["id"])
                    user_data = users.get(chat_id)
                    
                    # Ø§Ú¯Ø± Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯ Ø§Ø³Øª Ùˆ Ø¯Ø± Ø­Ø§Ù„ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø§Ø³Øª
                    if not user_data:
                        if text == "/start":
                            send_message(chat_id, "âœ… Ø³Ù„Ø§Ù…! Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ØŒ Ù„Ø·ÙØ§Ù‹ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø²ÛŒØ± Ø±Ø§ Ø¨Ù‡ ØªØ±ØªÛŒØ¨ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:\n\n1. ØªÙˆÚ©Ù† Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù… Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ù…Ø«Ù„: `123456789:ABCdefGhIJKlmnoPqrStUvWxYz`)\n2. Chat ID Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ù…Ø«Ù„: `153873572`)\n3. ØµØ±Ø§ÙÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± (coinex/binance)\n4. API Key\n5. Secret Key\n6. Ø­Ø§Ù„Øª Ù…Ø¹Ø§Ù…Ù„Ù‡ (spot/futures)\n7. Ø­Ø§Ù„Øª ØªØ³Øª (demo/real)\n8. Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ù„ (Ø¯Ù„Ø§Ø±)\n9. Ø³Ø±Ù…Ø§ÛŒÙ‡ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ (Ø¯Ù„Ø§Ø±)\n\nÙ„Ø·ÙØ§Ù‹ Ø§ÛŒÙ† 9 Ù…ÙˆØ±Ø¯ Ø±Ø§ ÛŒÚ©ÛŒ ÛŒÚ©ÛŒ Ø¨Ù‡ ØµÙˆØ±Øª Ù…ØªÙ†ÛŒ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.", bot_token=MAIN_BOT_TOKEN)
                            user_state[chat_id] = {"step": 1, "data": {}}
                            continue

                        if chat_id in user_state:
                            step = user_state[chat_id]["step"]
                            data = user_state[chat_id]["data"]

                            if step == 1:
                                data["bot_token"] = text
                                send_message(chat_id, "âœ… ØªÙˆÚ©Ù† Ø¨Ø§Øª Ø«Ø¨Øª Ø´Ø¯. Ø­Ø§Ù„Ø§ Chat ID Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.", bot_token=MAIN_BOT_TOKEN)
                                user_state[chat_id]["step"] = 2
                            elif step == 2:
                                data["chat_id"] = text
                                send_message(chat_id, "âœ… Chat ID Ø«Ø¨Øª Ø´Ø¯. Ø­Ø§Ù„Ø§ ØµØ±Ø§ÙÛŒ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (coinex/binance)", bot_token=MAIN_BOT_TOKEN)
                                user_state[chat_id]["step"] = 3
                            elif step == 3:
                                if text.lower() not in ["coinex", "binance"]:
                                    send_message(chat_id, "âŒ ØµØ±Ø§ÙÛŒ Ø¨Ø§ÛŒØ¯ coinex ÛŒØ§ binance Ø¨Ø§Ø´Ø¯. Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.", bot_token=MAIN_BOT_TOKEN)
                                    continue
                                data["exchange"] = text.lower()
                                send_message(chat_id, "âœ… ØµØ±Ø§ÙÛŒ Ø«Ø¨Øª Ø´Ø¯. Ø­Ø§Ù„Ø§ API Key Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.", bot_token=MAIN_BOT_TOKEN)
                                user_state[chat_id]["step"] = 4
                            elif step == 4:
                                data["api_key"] = text
                                send_message(chat_id, "âœ… API Key Ø«Ø¨Øª Ø´Ø¯. Ø­Ø§Ù„Ø§ Secret Key Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.", bot_token=MAIN_BOT_TOKEN)
                                user_state[chat_id]["step"] = 5
                            elif step == 5:
                                data["api_secret"] = text
                                send_message(chat_id, "âœ… Secret Key Ø«Ø¨Øª Ø´Ø¯. Ø­Ø§Ù„Ø§ Ø­Ø§Ù„Øª Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (spot/futures)", bot_token=MAIN_BOT_TOKEN)
                                user_state[chat_id]["step"] = 6
                            elif step == 6:
                                if text.lower() not in ["spot", "futures"]:
                                    send_message(chat_id, "âŒ Ø­Ø§Ù„Øª Ø¨Ø§ÛŒØ¯ spot ÛŒØ§ futures Ø¨Ø§Ø´Ø¯.", bot_token=MAIN_BOT_TOKEN)
                                    continue
                                data["trade_mode"] = text.lower()
                                send_message(chat_id, "âœ… Ø­Ø§Ù„Øª Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø«Ø¨Øª Ø´Ø¯. Ø­Ø§Ù„Ø§ Ø­Ø§Ù„Øª ØªØ³Øª Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (demo/real)", bot_token=MAIN_BOT_TOKEN)
                                user_state[chat_id]["step"] = 7
                            elif step == 7:
                                if text.lower() not in ["demo", "real"]:
                                    send_message(chat_id, "âŒ Ø­Ø§Ù„Øª Ø¨Ø§ÛŒØ¯ demo ÛŒØ§ real Ø¨Ø§Ø´Ø¯.", bot_token=MAIN_BOT_TOKEN)
                                    continue
                                data["is_demo"] = (text.lower() == "demo")
                                send_message(chat_id, "âœ… Ø­Ø§Ù„Øª ØªØ³Øª Ø«Ø¨Øª Ø´Ø¯. Ø­Ø§Ù„Ø§ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ù„ (Ø¯Ù„Ø§Ø±) Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.", bot_token=MAIN_BOT_TOKEN)
                                user_state[chat_id]["step"] = 8
                            elif step == 8:
                                try:
                                    data["total_wallet_balance"] = float(text)
                                    send_message(chat_id, "âœ… Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ù„ Ø«Ø¨Øª Ø´Ø¯. Ø­Ø§Ù„Ø§ Ø³Ø±Ù…Ø§ÛŒÙ‡ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ (Ø¯Ù„Ø§Ø±) Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.", bot_token=MAIN_BOT_TOKEN)
                                    user_state[chat_id]["step"] = 9
                                except:
                                    send_message(chat_id, "âŒ Ù„Ø·ÙØ§ ÛŒÚ© Ø¹Ø¯Ø¯ Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.", bot_token=MAIN_BOT_TOKEN)
                            elif step == 9:
                                try:
                                    data["trading_capital"] = float(text)
                                    # Ø°Ø®ÛŒØ±Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø¯Ø± users.json
                                    users[chat_id] = data
                                    save_users(users)
                                    del user_state[chat_id]
                                    send_message(chat_id, "ğŸ‰ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯!\n\nØ±Ø¨Ø§Øª Ø´Ù…Ø§ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª.\n\nØ¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù…Ù†ÙˆØŒ /start Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯.", bot_token=MAIN_BOT_TOKEN)
                                    show_main_menu(chat_id)
                                except:
                                    send_message(chat_id, "âŒ Ù„Ø·ÙØ§ ÛŒÚ© Ø¹Ø¯Ø¯ Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.", bot_token=MAIN_BOT_TOKEN)
                    else:
                        # Ú©Ø§Ø±Ø¨Ø± Ù‚Ø¨Ù„Ø§Ù‹ ØªÙ†Ø¸ÛŒÙ…Ø§ØªØ´ Ø±Ø§ Ú©Ø±Ø¯Ù‡
                        if text == "/start":
                            show_main_menu(chat_id)
                        elif text == "/report":
                            send_performance_report(chat_id)
                        elif text == "/status":
                            show_status(chat_id)
                if "callback_query" in update:
                    cd = update["callback_query"]["data"]
                    chat_id = str(update["callback_query"]["message"]["chat"]["id"])
                    if cd.startswith("main_menu_"):
                        show_main_menu(chat_id)
                    elif cd.startswith("settings_"):
                        show_settings_menu(chat_id)
                    elif cd.startswith("report_"):
                        send_performance_report(chat_id)
                    elif cd.startswith("status_"):
                        show_status(chat_id)
                    elif cd.startswith("stop_bot_"):
                        # Ø§ÛŒÙ†Ø¬Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ù…Ù†Ø·Ù‚ Ù…ØªÙˆÙ‚Ù Ú©Ø±Ø¯Ù† Ø±Ø¨Ø§Øª Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø®Ø§Øµ Ø±Ø§ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯
                        send_message(chat_id, "ğŸ›‘ Ø±Ø¨Ø§Øª Ù…ØªÙˆÙ‚Ù Ø´Ø¯.", bot_token=load_users().get(str(chat_id), {}).get("telegram_token"))
                    elif cd.startswith("start_bot_"):
                        # Ø§ÛŒÙ†Ø¬Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ù…Ù†Ø·Ù‚ Ø´Ø±ÙˆØ¹ Ø±Ø¨Ø§Øª Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø®Ø§Øµ Ø±Ø§ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯
                        send_message(chat_id, "ğŸŸ¢ Ø±Ø¨Ø§Øª Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø´Ø±ÙˆØ¹ Ø´Ø¯.", bot_token=load_users().get(str(chat_id), {}).get("telegram_token"))
                    elif cd.startswith("select_exchange_"):
                        show_exchange_selection(chat_id)
                    elif cd.startswith("select_mode_"):
                        show_mode_selection(chat_id)
                    elif cd.startswith("select_trade_mode_"):
                        show_trade_mode_selection(chat_id)
                    elif cd.startswith("select_coinex_"):
                        # Ø°Ø®ÛŒØ±Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ ØµØ±Ø§ÙÛŒ
                        users = load_users()
                        user = users.get(chat_id)
                        if user:
                            user["exchange"] = "coinex"
                            save_users(users)
                            send_message(chat_id, "âœ… ØµØ±Ø§ÙÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯: CoinEx", bot_token=user["telegram_token"])
                            show_settings_menu(chat_id)
                    # ... Ø³Ø§ÛŒØ± Ø¯Ø³ØªÙˆØ±Ø§Øª ...
        except Exception as e:
            logger.error(f"Telegram message handling error: {e}")
            time.sleep(1)

# ===============================
# 12. Ø­Ù„Ù‚Ù‡ Ø§ØµÙ„ÛŒ
# ===============================
def main_loop():
    global is_running
    threading.Thread(target=handle_telegram_messages, daemon=True).start()
    
    while True:
        try:
            users = load_users()
            for chat_id, user_data in users.items():
                if all_settings_completed(chat_id) and is_running_for_user(chat_id):
                    smart_bot = SmartTradingBot(chat_id)
                    if smart_bot.initialize():
                        smart_bot.run_cycle()
            
            time.sleep(300)  # Ù‡Ø± 5 Ø¯Ù‚ÛŒÙ‚Ù‡ ÛŒÚ© Ø¨Ø§Ø± Ú†Ú© Ú©Ù†
        except Exception as e:
            logger.error(f"Main loop error: {e}")
            time.sleep(2)

# ===============================
# Ø´Ø±ÙˆØ¹ Ø¨Ø±Ù†Ø§Ù…Ù‡
# ===============================
if __name__ == "__main__":
    logger.info("ğŸš€ Smart Trading Bot starting...")
    main_loop()
